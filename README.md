# learn-dotnet-eshop-microservices

.NET 8 微服务 DDD、CQRS、垂直切片架构/整洁架构。

## 一、介绍 (Introduction)

基于 .NET 平台构建微服务，将使用以下技术并基于云原生环境进行最佳实践的开发：

- 架构与设计原则
	- Layered Architecture ( 分层架构 )
	- Vertical Slice Architecture ( 垂直切片架构 )
	- DDD ( 领域驱动设计 )
	- Clean Architecture ( 整洁架构 )
	- CQRS ( 命令与查询职责分离 )
	- SOLID、DI
	- 中介者模式、代理模式、装饰器模式、选项模式
	- 发布订阅、缓存
- 服务通信与集成
	- ASP.NET WebA API
	- gRPC
	- RabbitMQ
	- MassTransit
	- YARP API Gateway
- 数据存储
	- PostgreSQL
	- SQL Server
	- SQLite
	- Redis
- 类库
	- Refit
	- Carter
	- Marten
	- MediatR
	- Mapster
	- MassTransit
	- FluentValidation
	- Entity Framework Core
- 容器化与编码 ( Containerization and Orchestration )
	- Docker
	- Dockerfile
	- Docker Compose

通过开发电商模块，并结合 NoSQL 数据库 ( PostgreSQL DocumentDB、Redis ) 和关系型数据库 ( SQL Server、SQLite )，通过 RabbitMQ 实现事件驱动的异步通信，同时利用 Yarp API 网关进行统一入口管理。来逐步实现一个完整的 .NET 微服务架构设计与实现。

将开发以下微服务及功能模块：

**商品目录 ( Category )**
- ASP.NET Core Minimal APIs 以及 .NET 8 和 C# 12 的最新特性
- 基于功能文件夹 ( Feature Folders ) 和 垂直切片架构 ( Vertical Slice Architecture ) 实现
- 基于 MediatR 实现 CQRS 模式
- 基于 MediatR 与 FluentValidation 的 CQRS 验证管道行为 ( Validation Pipeline Behaviours )
- 使用 Marten 库在 PostgreSQL 上实现 .NET 事务型文档数据库
- 使用 Carter 库定义 Minimal API 接口
- 横切关注点 ( 关注点分离 )：日志记录、全局异常处理和健康检查
- 用于在 Docker 环境中运行多容器的 Dockerfile 和 docker-compose 文件

**购物车 ( Basket )**
- 遵循 RESTful API 原则的 ASP.NET 8 Web API 应用，实现 CRUD 操作
- 使用 Redis 作为购物车数据库的分布式缓存
- 实现代理 ( Proxy )、装饰器 ( Decorator )、和缓存旁路 ( Cache-aside ) 设计模式
- 调用折扣 ( Discount ) gRPC 服务、实现服务间同步通信以计算商品最终架构
- 使用 MassTransit 和 RabbitMQ 发布 购物车结算 消息队列

**折扣 ( Discount )**
- ASP.NET 8 gRPC 服务端应用
- 与 购物车 ( Basket ) 微服务构建高性能的同步 gRPC 通信
- 通过定义 Protobuf 消息暴露 gRPC 服务
- 使用 Entity Framework Core ORM 及数据库迁移 ( Migrations )
- SQLite 数据库连接与容器化

**订单 ( Ordering )**
- 采用最佳实践实现 DDD、CQRS 和整洁架构 ( Clean Architecture )
- 使用 MediatR、FluentValidation 和 Mapster 开发 CQRS
- 使用领域事件 ( Domain Events ) 与集成事件 ( Integration Events )
- Entity Framework Core 的 Code-First 模式、迁移 ( Migrations ) 及 DDD 实体配置
- 通过 MassTransit 配置消费 RabbitMQ 的 购物车结算 事件队列
- SQL Server 数据库连接与容器化
- 使用 Entity Framework Core ORM，并在应用启动时自动迁移至 SQL Server

**购物应用 ( Shopping App )**
- 基于 Bootstrap4 和 Razor 模板的 ASP.NET Core Web 应用
- 使用 Refit 配合生成的 IHttpClientFactory 调用 Yarp API 网关接口
- ASP.NET Core Razor 工具：视图组件、局部视图、标签助手、模型绑定与验证、Razor区块等

**微服务通信机制**
- 服务间同步通信：gRPC
- 微服务异步通信：基于 RabbitMQ 消息代理服务
- 使用 RabbitMQ 的发布/订阅 ( Publish/Subscribe ) 主题交换模型 ( Topic Exchange )
- 使用 MassTransit 对 RabbitMQ 消息代理系统进行抽象封装
- 由 购物车 ( Basket ) 微服务发布 购物车结算 事件队列，订单 ( Ordering ) 微服务订阅该事件
- 创建 RabbitMQ 事件总线 ( EventBus ) 类库，供各微服务使用。

**Yarp API Gateway**
- Yarp 反向代理实现API网关、应用网关路由模式 ( Gateway Routing Pattern )
- Yarp 反向代理配置：路由 ( Route ) 、集群 ( Cluster )、路径 ( Path ) 、转换 ( Transform ) 、目标 ( Destinations )
- Yarp 反向代理配置中使用 FixedWindowLimiter 实现速率限制 ( Rate Limiting )
- 使用 API 网关进行 重路由

**Docker Compose 整合所有微服务**
- 微服务容器化
- 编排微服务及其支撑微服务 ( 数据库、分布式缓存、消息代理 )
- 覆盖环境变量以适配不同运行环境

在微服务中采用分层应用架构，实现 N层六边形架构 (核心层、应用层、基础设施层和表示层)，采用领域驱动设计 ( 实体、仓储、领域/应用服务、DTO等 )，目标是构建一个符合整洁架构原则的项目模板，同时贯彻松耦合、依赖倒置等架构最佳实践，并应用依赖注入、日志记录、验证、异常处理等设计模式。

### 课程目标

- 掌握使用设计模式、原则和最佳实践开发 .NET 8 微服务的核心技能，成为该领域的专家。
- 面向软件开发人员和架构师设计。
- 运用云原生微服务的设计模式与原则，落实行业最佳实践。
- 深入掌握 C# 12、.NET 8 和 ASP.NET 8 的最新特性，例如 Minimal API、主构造函数等。
- 全面理解 .NET 8 微服务架构，具备独立设计、开发和部署微服务应用的能力。

### 源码 ( Source Code )

aspnetrun 组织源码：
https://github.com/aspnetrun/run-aspnetcore-microservices

课程源码：
https://github.com/mehmetozkaya/EShopMicroservices

课程每章源码：
https://github.com/mehmetozkaya/EShopMicroservices-Udemy-Sections

## 二、微服务架构

软件架构的演进始于单体架构 (Monolithic)。在业务发展初期，单体架构凭借其简单易部署的特点，能快速满足业务需求。然而，随着业务规模的不断扩大，单体应用的代码量持续增加，维护成本上升，为了提升可维护性和开发效率，模块化单体架构 (Modular Monolithic) 应运而生，它将单体应用拆分为多个模块，实现了一定程度的解耦。

当用户量进一步增长，业务逻辑愈发复杂，单体架构的性能瓶颈逐渐凸显，如扩展困难、故障影响范围大等问题。为了应对这些挑战，微服务架构 (Microservices) 出现了。微服务将应用拆分为多个小型、独立且松耦合的服务，每个服务可独立开发、部署和扩展，有效提升了系统的灵活性和可扩展性。

随着云计算技术的发展，Serverless 架构成为新的趋势。这是一种基于事件驱动的架构风格，它将应用程序拆分为多个小型函数，每个函数负责处理特定的事件。开发人员无需关注服务器的管理和运维，只需专注于业务逻辑的实现，进一步降低了开发和运维成本。

### 1. 什么是微服务？

- 微服务是小型、独立且松耦合的服务，能够协同工作。
- 微服务通过定义明确的API相互通信。
- 微服务可以独立且自主地部署。
- 微服务支持多种不同的技术栈配合使用，具有技术无关性 ( 即不依赖特定技术 )。
- 每个服务都有独立的代码库，可由小型开发团队进行管理。
- 每个微服务拥有自己的数据库，不与其他服务共享。

### 2. 什么是微服务架构？

微服务架构风格是一种将单个应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，并通过轻量级通信机制（通常为 HTTP 或 gRPC API）进行交互。

- 微服务围绕业务功能进行构建，并可通过全自动化的部署流程实现独立部署。  
- 微服务架构将应用程序拆分为多个小型、独立的服务，这些服务通过明确定义的 API 进行通信，每个服务由小型、自治的团队负责维护。
- 微服务架构是一种云原生的架构方法，其中应用程序由许多松耦合、可独立部署的小型组件构成。 
- 微服务拥有各自的技术栈，通过 RESTful API 等方式进行相互通信，按业务能力组织，并具有明确的边界范围，即限界上下文（Bounded Contexts）。  
- 遵循单一职责原则（Single Responsibility Principle），即根据不同的服务来划分各自的职责。

> [Martin Fowlers Microservices article](https://martinfowler.com/articles/microservices.html)

### 3. 微服务特征 ( Characteristics )

- 通过服务实现组件化  
- 围绕业务能力组织  
- 以产品而非项目为导向  
- 采取智能的终端与简单的传输机制，即智能端点(smart endpoints)，哑管道（Dumb Pipes）  
- 实施去中心化的治理模式  
- 实现去中心化的数据管理
- 基础设施自动化  
- 为故障而设计（容错设计）

### 4. 微服务优势 ( Benefits )

**敏捷性、创新能力和更快的上市速度**
微服务架构使应用程序更易于扩展、更快速地开发，从而促进创新，并加速新功能的上市时间。

**灵活的可扩展性**
微服务可以独立扩展，因此你可以仅对资源需求较少的子服务进行横向扩展，而无需扩展整个应用程序。

**小型、专注的团队**
微服务应足够小，使得单一功能团队即可独立完成其构建、测试和部署。

**小型且隔离的代码库**
微服务不与其他服务共享代码或数据存储，这最大限度地减少了依赖关系，从而更易于添加新功能。

**易于部署**
微服务实现了持续集成与持续部署(CI/CD)，使得每个服务的部署更加简单和自动化。同时在某些方案失败时也能迅速回退到之前的状态。

**技术无关性**
微服务架构不依赖于任何特定的技术栈，开发人员可以根据业务需求选择最适合的技术。并在各自的服务中混合使用多种技术栈。

**弹性与故障隔离**
微服务具有容错能力，能够通过实现重试机制与断路器模式等方式正确处理故障。

**数据隔离**
根据微服务设计，各个数据库都是相互独立的。这样进行数据库更新会更容易，因为只要修改其中一个数据库即可。

### 5. 微服务面临的挑战 ( Challenges )

**复杂性**
每个服务本身更简单，但整个系统却变得更加复杂。当存在数百个微服务时，部署和通信将会变得非常繁琐。

**网络问题与延迟**
微服务通过服务间通信进行交互，因此需要应对网络问题。服务链路的增加会加剧延迟问题，并导致频繁的API调用。

**开发与测试**
与单体架构相比，在微服务架构中开发和端到端(E2E)测试这些流程更加困难。

**数据完整性**
每个微服务拥有自己的数据持久化机制，因此数据一致性将成为一项挑战。应尽可能遵循最终一致性原则。

**部署**
部署工作极具挑战性，需要投入大量资源来构建DevOps自动化流程和工具。微服务的复杂性使得人工部署将变得几乎不可能完成。

**日志与监控**
分布式系统需要将各种日志集中起来，以便全面了解系统的运行状况。通过这种集中式的日志管理方式，可以更容易地识别问题的根源。

**调试**
通过本地IDE进行调试已不再可行，因为在数十和数百个微服务的环境中，手动调试将变得非常困难。

### 6. 何时使用微服务架构

**确保你拥有实施微服务的“充分理由”**
你的应用程序是否真的需要依赖微服务来提升灵活性。如果你的应用程序确实需要具备快速上市的能力，即能够实现零延迟部署，并且各个组件能够独立更新，那么微服务无疑是一个非常有效的解决方案。

**通过逐步进行小规模修改来推进开发过程，同时将单进程的单体应用作为默认方案**
在开发过程中，可以通过逐步将单体应用程序中的某个模块拆分为微服务来实现迭代和重构。

**需要实现新功能的同时确保系统零停机时间**
当一个组织需要对现有功能进行修改，并且希望在不影响系统其他部分正常运行的情况下部署这些新功能时，就需要满足这一要求。

**需要能独立扩展应用程序的某一部分**
必须确保微服务能够拥有自己的数据存储机制，然而，数据一致性往往是一个难以解决的难题，这种情况下，需要采用最终一致性原则来确保数据的最终一致。

**使用不同数据库技术进行数据分区**
当需要为各种不同的使用场景存储和扩展数据时，微服务就显得极为实用，团队可以根据自身需求，逐步选择适合开发这些服务的技术。

**具备组织升级能力的自主团队**
微服务有助于推动团队和组织的演进与升级，组织需要将职责下放至各个团队，使每个团队都能自主决策并独立开发软件。

### 7. 何时不应使用微服务

**不要采用分布式单体架构**

**不要在没有DevOps或没有云服务支持下采用微服务架构**

**团队规模有限**
如果你的团队规模无法应对微服务带来的工作负载，那么只会导致项目交付的延迟。

对于小团队来说，采用微服务架构并不划算，因为这个团队本身就需要负责微服务的部署和管理工作。

**全新的产品或初创公司**
如果你正在开发一个全新的产品或初创企业，且在产品开发与迭代过程中需要做出重大调整，那么你不应该从采用微服务架构开始着手。

在重新设计业务架构时，微服务模式往往会带来高昂的成本。即便你最终取得了足够的成功，从而需要采用高度可扩展的架构，这些成本依然难以避免。

**共享数据库**
不要使用共享数据库(单一数据库)这种反模式。

### 8. 单体架构与微服务架构的对比

**应用程序架构**
单体应用的结构非常简单直接，由一个不可分割的完整单元构成。而微服务则具有复杂的结构，它由多种不同类型的服务和数据库组成。

**可扩展性**
单体应用程序是作为一个整体进行扩展的，而微服务则可以实现不均匀的扩展。这种特性促使许多企业将他们的应用程序迁移到微服务架构上。

**部署**
单体应用程序能够实现整个系统的快速、便捷部署；而微服务则能够保证系统零停机时间，并实现持续集成/持续部署的自动化流程。

**开发团队**
如果你的团队没有使用微服务和容器系统的经验，那么构建基于微服务的应用程序将会非常困难。